#!/usr/bin/python2.6"""Libb2svgBenjamin Debski <benjamin.debski@gmail.com>started 21st/September/2009restarted 20/February/2010"""from xml.dom import minidomimport Box2D as box2dimport mathfrom bezier import *class LoadSVG(object):	objectList = []	def __init__(self, file=None, world=None, ratio=1, quality=30):		self.file = file		self.world = world		self.RATIO = ratio		self.quality = quality		self.dom = minidom.parse(open(self.file, 'r'))		self.HEIGHT = int(self.dom.getElementsByTagName('svg')[0].getAttribute('height'))		self.WIDTH = int(self.dom.getElementsByTagName('svg')[0].getAttribute('width'))		if self.dom.getElementsByTagName('title') != []:			print "Level:", self.dom.getElementsByTagName('title')[0].firstChild.data		self.svg = self.dom.getElementsByTagName('svg')[0]		self.dom = self.svg.getElementsByTagName('g')[0]		print "Level:", self.file, "width =", self.WIDTH, "height =", self.HEIGHT		self.createDefaultWorld()		self.loadPath()		self.loadBox()		self.loadCircle()		self.loadObjects()		LoadSVG.objectList = self.objectList	def createDefaultWorld(self):		worldAABB = box2d.b2AABB()		worldAABB.lowerBound = (-2049.0 / self.RATIO, -2049.0 / self.RATIO)#FIXME DYNAMIC		worldAABB.upperBound = (2049.0 / self.RATIO, 2049.0 / self.RATIO)#FIXME DYNAMIC		if self.world is None:			gravity = (0, -self.RATIO)#should be -9.0m			doSleep = False			self.world = box2d.b2World(worldAABB, gravity, doSleep)		else:			self.world.worldAABB.lowerBound = (-8.0, -8.0)			self.world.worldAABB.upperBound = (self.WIDTH / self.RATIO + 8, self.HEIGHT / self.RATIO + 8)		loop = [			(0.0, 0.0),			(0.0, self.HEIGHT / self.RATIO),			(self.WIDTH / self.RATIO, self.HEIGHT / self.RATIO),			(self.WIDTH / self.RATIO, 0.0),			]		border = [(i[0], i[1]) for i in loop]		self.createSegments(border, loop=True)	def loadObjects(self):		LoadSVG.objectList = []		for node in self.dom.getElementsByTagName('image'):			custom = {}			"""for attribute in node.attributes.keys():				print attribute, node.attributes[attribute].nodeValue"""			for (name, value) in node.attributes.items():				if name not in ("id", "style", "sodipodi:absref", "xlink:href", "inkscape:label"):#Filter out unwanted attributes					custom[name] = value			#print filter(lambda item: item not in ("sodipodi:absref", "id"), custom)			LoadSVG.objectList.append({				'label':node.getAttribute('inkscape:label'),				'width': int(node.getAttribute('width')),				'height': int(node.getAttribute('height')),				'x': float(node.getAttribute('x')),				'y': self.HEIGHT - float(node.getAttribute('y')),				'custom': custom			})	def createSegments(self, bezier_verts, loop=False):		ed = box2d.b2EdgeChainDef()		ed.setVertices_b2Vec2(bezier_verts)		ed.isALoop = loop		bd=box2d.b2BodyDef()		bd.position = ( 0.0, 0.0 )		body = self.world.CreateBody(bd)		body.SetUserData("ground")		body.CreateShape(ed)	def createBox(self, x, y, width,height):		sd1=box2d.b2PolygonDef()		sd1.SetAsBox(width, height)		sd1.density = 2.0		bd=box2d.b2BodyDef()		bd.position = (x, y)		body = self.world.CreateBody(bd)		body.CreateShape(sd1)	def createCircle(self, x, y, radius, quality=8):		shapeDef = box2d.b2CircleDef()		shapeDef.radius = radius		shapeDef.density = 2.0		bodyDefinition = box2d.b2BodyDef()		bodyDefinition.position = (x, y)		body = self.world.CreateBody(bodyDefinition)		body.CreateShape(shapeDef)	def createEllipticalArc(self, p1, p2, radiusX, radiusY, quality=8):		#calculate the angle		#find the center		"""startX = math.asin((p1.x/rX)/2)/(math.pi/180.0)		startY = math.acos((p1.y/rY)/2)/(math.pi/180.0)		startAng = (startX+startY)/2		finishX = math.asin((p2.x/rX)/2)/(math.pi/180.0)		finishY = math.acos((p2.y/rY)/2)/(math.pi/180.0)		finishAng = (startX+startY)/2		print "EA angles:", startAng, finishAng		x = startX		y = startY		pPoint = (x,y)		for ang in range(8):			y -= math.cos(ang*(3.14159265/180))*rX			x += math.sin(ang*(3.14159265/180))*rY			self.createSegments([(x,y),pPoint])			pPoint = (x,y)"""		pass	def loadBox(self):		for i in self.svg.getElementsByTagName('rect'): #Consider using switch statment instead			width = float(i.attributes['width'].value) / 2			height = float(i.attributes['height'].value) / 2			x = (float(i.attributes['x'].value) + width) / self.RATIO			y = (self.HEIGHT - float(i.attributes['y'].value) - height) / self.RATIO			self.createBox(x, y, width / self.RATIO, height / self.RATIO)	def translatePath(self, datapath):		self.list = datapath.split()		length = len(self.list)		self.index = 0		while self.index < length:			#print self.list[self.index]			#print "NEXT ELEMENT = ", self.list[self.index]			if self.list[self.index] == 'M' or self.list[self.index] == 'm':#Does not work with multiple moveto commands atm				self.index += 1				vert = self.list[self.index].split(',')				p1=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				self.index += 1			elif self.list[self.index] == 'C':				self.index += 1				vert = self.list[self.index].split(',')				p2=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				self.index += 1				vert = self.list[self.index].split(',')				p3=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				self.index += 1				vert = self.list[self.index].split(',')				p4=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				self.index += 1				#print p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y				self.createSegments(calculate_bezier(p=[p4,p3,p2,p1]))#Left to right = floor, right to left = ceiling				p1=p4			elif self.list[self.index] == 'L':				self.index += 1				vert = self.list[self.index].split(',')				p2=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				#self.createLine([p1,p2])				self.createSegments([p2,p1])#Left to right = floor, right to left = ceiling				self.index += 1				p1=p2			elif self.list[self.index] == 'z':				self.index += 1			elif self.list[self.index] == 'A':				return#Add Arc				self.index += 1				print "P2 aka radius:", self.list[self.index]				vert = self.list[self.index].split(',')				#p2=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				p2=box2d.b2Vec2(float(vert[0])/self.RATIO,float(vert[1])/self.RATIO)				print p2				print "MAN CALC:", float(vert[1])/self.RATIO				self.index += 1				self.index += 1				self.index += 1				self.index += 1				print self.list[self.index]				vert = self.list[self.index].split(',')				p3=box2d.b2Vec2(float(vert[0])/self.RATIO,(self.HEIGHT-float(vert[1]))/self.RATIO)				#self.createSegments([p1,p3])				#self.createEllipticalArc(p1, p3, p2.x, p2.y)				self.index += 1		#Optimize code, one body per path instead of one body per segment?, will that work/how well?	def loadPath(self):		for node in self.dom.getElementsByTagName('path'):			self.translatePath(node.getAttribute('d'))	def loadCircle(self):		for node in self.dom.getElementsByTagName('circle'):			x = float(node.getAttribute('cx')) / self.RATIO			y = (self.HEIGHT - float(node.getAttribute('cy'))) / self.RATIO			radius = float(node.getAttribute('r')) / self.RATIO			self.createCircle(x, y, radius)def SVG2B2D(file=None, world=None, ratio=1, quality=30):	return LoadSVG(file, world, ratio, quality).world